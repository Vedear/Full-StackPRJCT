Модуль 4. Теория Бэкэнда

Node.js это среда выполнения для JS построенная на движке V8 из гугл хром. Node.js позволяет запускать JS код вне браузера. Node.js можно установить как на сервер, так и локально на компьютер. Node.js поддерживает ассинхронный ввод-вывод, но является однопоточным, т.к. JS не поддерживает многопоточный режим работы
Ключевые особенности: 
1) Ассинхронность и событийно-ориентированная архитектура 
1. Неблокирующий input/output. Когда Node.js приложению нужно выполнить операцию ввода вывода прочитать файл с диска, обратиться к бд , она не ждет его завершения, вместо этого продолжает выполняет другой код. Как только операция завершается вызывается специальная функция-обработчик.
2. Однопоточность с циклом событий (ivent loop). В основе ode.js лежит однопоточная модель, однако это не значит что он может делать только одну вещь за раз, цикл событий это механизм который проверяет завершились какие либо ассинхронные операции, если операция завершена, node.js ставит ее вызов в очередь на выполнение.
2) NPM (Node Package Manager)

Этапы разработки серверной части на Node.js:
1) Подготовка и инициализация проекта 
1. Созданиие корневой папки проекта (папки: сервер, клиент) 
2. Установка модулей и зависимостей (

express - полноценный фреймворк для создания сервера и маршрутизации, 
pg - отвечает за связь с базой данных PostgreSQL, 
cors - нужен для входящих/исходящих подключений сервера, 
dotenv - позволяет выносить переменные в "виртуальное окружение", 
-D nodemon - позволяет работать с кодом на сервере не перезагружая его каждый раз, после внесения изменений, 
sequlize - позволяет создавать модели данных (позволяет на языке js записать обекты как функции))

2) Создание базового HTTP сервера с помощью Express
3) Подключение к БД
1. Создание конфигурационного файла для подключения к БД
4) Определение модели данных (схема)
5) Создание маршрутов (routes) и API EndPoits
1. Разработка обработчиков для различных HTTP запросов (GET, POST, PUT, DELETE по определенным URL адресам (EndPoit))
6) Разработка контроллеров (Controllers) 
1.Написание функций обработчиков, которые привязаны к маршрутам. Этти функции содержат бизнес логику: получают данные из запроса (модели), взаимодействуют с БД и отправляют ответ пользователю
7) Обработка ошибок и валидация данных Поверх контроллеров зачасту добавляют обработчики ошибок (промежуточные), которые проводят валидацию данных 
8) Настройка переменных окружения - вынесение конфеденциальной информации в отдельный файл

HTTP методы 

HTTP методы определяют действие, которое клиент хочет выполнить с конкретным ресурсом на сервере. Они являются основой RESTful API.
Методы:
1) Get - это безопасный метод для получения данных с сервера. Пример get/api/clients - все данные, get/api/clients/2 - 
2) Post - это небезопасный метод создания и отправки данных, данные передаются в теле запроса. Пример post/api/clients
3) Put - это небезопасный метод, который полная замена или обновления ресурса, если не существует может создать
4) Patch - небезопасный метод, который может заменить
5) Delete - небезопасный метод, удаляет данные

Коды ответов сервера

Коды ответов сервера - это числовые данные, которые сервер отправляет в ответ на http запрос клиента. 
Коды статуса HTTP подразделяются на пять классов в зависимости от их первой цифры:
1xx - Информационный ответ, который означает, что сервер получил начальную часть запроса клиента и ожидает продолжения передачи оставшихся данных
2xx - Запрос клиента выполнен успешно (200 - Ок (применяется для Get, Post, Patch), 201 - Create, 204 - Delete)
3xx - Означают «перенаправление» и указывают, что для выполнения запроса клиенту нужно предпринять дополнительные действия, например, перейти по другому URL-адресу, который сервер указывает в заголовках ответа
4xx - Означает ошибку на стороне клиента, указывая на проблему с запросом, например, неверный URL, отсутствие аутентификации или неверный синтаксис, который препятствует успешному выполнению запроса (400 - «Вad Request» сервер не может обработать запрос из-за некорректного синтаксиса, 401 - «Unauthorized» запрос не был выполнен, потому что у клиента нет действительных учётных данных для доступа к целевому ресурсу, 403 -  означает «Forbidden» (Доступ запрещён) и говорит о том, что сервер понял запрос, но отказывается его выполнить из-за ограничений прав доступа пользователя к запрашиваемому ресурсу, 404 - «Not Found» (Не найдено), означает, что сервер не смог найти запрошенный ресурс (например, страницу или файл) по указанному адресу, 429 - «Too Many Requests» означает, что клиент отправил слишком много запросов за короткий промежуток времени, превысив установленные сервером ограничения по скорости)
5xx - Означают ошибку сервера, то есть запрос клиента корректен, но сервер по внутренней причине не может его выполнить (500 - «Internal Server Error» означающий, что на веб-сервере произошла непредвиденная внутренняя ошибка, которая помешала ему выполнить запрос клиента, 502 - «Bad Gateway» означает, что прокси-сервер получил некорректный ответ от вышестоящего сервера, 503 - «Service Unavailable» («Сервис временно недоступен») означает, что сервер не может обработать запрос из-за временной перегрузки или проведения технических работ)

https://www.dotenv.org/docs/quickstart

Методы подключения модулей:
COMMONJS | ESM

В папке "server" создаём файлы "db.js", ".env" и "index.js"
В консоли прописываем команды:
npm init -y
npm install express cors pg pg-hstore sequelize dotenv
Это нужно для инициализации Node.JS и загрузки нужных модулей

// Справка для того, что ниже
require ("dotenv").config(); - Устаревший метод типа COMMONS
import 'dotenv/config'; - Современный метод типа ESM

export conts myfunc =() => {}; //Стока для справки - ESM позволяет делать гибкую работу с объектами 

В index.js вписываем то, что ниже:
//
import 'dotenv/config'
import express from 'express'

const app = express()
const PORT = process.env.PORT
//.env    - файл в папке сервере
//PORT=5222

app.listen(PORT, () => {
	console.log (`сервер запущен на порту ${PORT}`
)})

Проверка - зайти в package.json: 
"scripts": {
	"dev" : "nodemon index.js"
},

//под автором ("autor":"",) вписать то, что ниже
"type" : "module"

Данную команду вписать в терминал
npm run dev

Sequlize

Создать в корне сервера файл db.js

import {Sequlize} from 'sequlize'
Метод позволяет применять параметры подключения к базам данных, порт, названия пользователя и пароль и т.д.

const sequelize = new Sequelize(
	process.env.DB_NAME,
	process.env.DB_USER,		// общие данные, ниже идут уникальные
	process.env.DB_PASSWORD, {
  host: process.env.DB_HOST,
  dialect: 'postgres',
  port: process.env.DB_port
})
export default sequelize;
	
То, что ниже, вписать в файл .env
DB_NAME=tahcidi
DB_USER=postgres
DB_PASSWORD=password
DB_HOST=localhost
DB_PORT=5432

PORT=5222

В файле index.js пишем асинхронную функцию (она запускает сервер):
//пример
const Start = async () => { // если Node.js видит async то она понимает, что функция будет асинхронной
	try {
		await sequelize.authenticate()
		app.listen(PORT, () => {
   		console.log(`сервер запущен на порту ${PORT}`
)})
		console.log('Успешное подключение к БД')
}	catch(error){ // это отрабатывается, если не выполнится try
		console.error('Не удалось подключиться к БД', error)
}}

Файл db.js содержит данные по sequelize

Метод sequelize.define позволяет создавать модели (пример):
const { Sequelize, DataTypes } = require('sequelize')
const sequelize = new Sequelize('sqlite::memory:')

const User = sequelize.define(
  'User',
  {
    // Здесь определяются атрибуты модели
    firstName: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    lastName: {
      type: DataTypes.STRING,
      // allowNull по умолчанию имеет значение true
    },
  },
  {
    // Здесь определяются другие настройки модели
  }
)

// `sequelize.define` возвращает модель
console.log(User === sequelize.models.User) // true


15.10.2025

Описание модели данных выглядит так:

const Client = sequelize.define ('clients', {
    id:{
        type : DataTypes.INTEGER,
        primaryKey : true,
        autoIncrement : true,
        allowNull : false
    },
    name:{
        type : DataTypes.STRING(55),
        allowNull : false
    },
    number:{
        type : DataTypes.STRING,
        allowNull : false
    },
    rating:{
        type : DataTypes.DECIMAL,
        defaultValue : 0
    },
    age:{
        type : DataTypes.DATE
    },
    role:{
        type : DataTypes.STRING,
        allowNull : false,
        dafaultValue : 'user'
    }
})

Чтобы синхронизировать модель с бд надо использовать sequelize.sync:

await sequelize.sync() - команда для синхронизации модели с базой данных, будет создавать при отсутсвии
await sequelize.sync( {force : true} ) - удалит бд и создаст новую
await sequelize.sync( {alter : true} ) - обновит бд и внесёт новую информацию, даже существующую

Вписывать эту команду внутри index.js в const Start = async () сразу после аутентификации

const Start = async () => {
	try {
		await sequelize.authenticate()
		await sequelize.sync( {alter : true} )
		app.listen(PORT, () => {
   		console.log(`сервер запущен на порту ${PORT}`
)})
		console.log('Успешное подключение к БД')
}	catch(error){ // это отрабатывается, если не выполнится try
		console.error('Не удалось подключиться к БД', error)
}}

Связи в sequelize для бд делают через команды hasOne\hasMany и belongsTo\belongsToMany
hasOne\hasMany определяют Первичный ключ -> Внешний ключ
belongsTo\belongsToMany определяют Внешний ключ -> Первичный ключ

В файле models.js после объявления сущностей перед запуском функции:
Client.hasOne(Order)
Order.belongsTo(Client)

Product.hasOne(OrderItem)
OrderItem.belongsTo(Product)

Order.hasOne(OrderItem)
OrderItem.belongsTo(Order)

д\з - пошариться по sequelize

16.10.2025
Создание маршрутов (routes) с помощью get-запроса

https://expressjs.com/en/guide/using-middleware.html#using-middleware
https://my-js.org/docs/cheatsheet/express-api

app.use(cors());
app.use(express.json()); // функция парсит json, то есть жрёт так, как он есть

app.get('/', (req, res) => {
	res.status(200).json({
		message: 'work'
	})
}) // работает, но надо доработать

1-ая доработка - сделать его асинхронным (async)
2 - обезопасить код, обернув в try/catch
3 - добавить обработку ошибок
4 - сделать более конкретным (/client)

app.get('/api/clients', async(req, res) => {
	try {const getClients = await Client.findAll();
		res.status(200).json(getClients)}
	catch (error) {
		res.status(500).json({message: 'Ошибка сервера при получении данных'})
	}
});

Такой код является доработанным.

Данными командой можно проверить работу get запроса. CORS нужно для безопасности.
При заходе на сайт http://localhost:5222 будет выдано сообщение в req.status.json

Функция get принимает в себя 2 параметра:
1) метод get (post, patch)
2) путь на сервере ('/','/api','/clients')
Дальше выполняется handler-функция с двумя объектами req (request) и res (response)
В req (принимает то, что прислал клиент, обычно браузер)
В res (обект ответа), сюда пишется ответ клиенту (на пример статус клиенту или json)


22.10.2025

try {const addClients = await Client.create({
		name: "Sidorovich",
		rating: 3,
		number : "3212",
		age : 45,
		role : "user",
		createdAt : '2025-10-08',
		updatedAt : '2025-10-08'
		});


28.10.2025

1) req.params
get /clients/1
req.params = {id:123}

2) req.query
get /clients&page=1    --- с таким работать не будем

3) req.body (тело запроса)
{name: "Ivanov", age : 30}